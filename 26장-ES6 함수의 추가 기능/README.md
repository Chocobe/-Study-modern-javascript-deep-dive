# 26장. ES6 함수의 추가 기능

# 1. 함수의 구분

`ES6` 이전의 `함수` 는 목적을 구분하지 않는 모두 동일한 형태의 `함수` 였습니다.

그래서 `생성자 함수`, `메서드`, `콜백` 모두 `callable` 이며 `constructor` 였습니다.

즉, 모든 함수는 `생성자 함수` 로 호출할 수 있다는 것입니다.

문제는 `생성자 함수` 에만 필요한 `prototype` 프로퍼티가 다른 목적의 함수에도 모두 존재하게 되는 것 입니다.

모든 함수에 `prototype` 프로퍼티가 있게되니, 성능상의 문제와 잘못된 사용을 유발하는 문제점을 가졌습니다.

<br />

`ES6` 에서는 함수를 `사용 목적` 에 따라 다음과 같이 구분하며, 함수 스코프 내에 제공되는 정보가 달라졌습니다.

<br />

|ES6 함수의 구분|constructor|prototype|super|arguments|구분|
|:---|:---|:---|:---:|:---:|:---:|
|일반함수(Normal Function)|⭕️|⭕️|❌|⭕️|`constructor`|
|메서드(Method)|❌|❌|⭕️|⭕️|`non-constructor`|
|화살표 함수(Arrow Function)|❌|❌|❌|❌|`non-constructor`|



<br /><hr /><br />



# 2. 메서드

이전에는 객체에 바인딩된 모든 함수를 메서드라고 불렀다면, `ES6` 부터 `메서드` 는 오직 `메서드 축약 표현` 으로 정의한 함수만을 가리킵니다.

`메서드 축약 표현` 으로 정의한 함수는 `non-constructor` 로 생성되기 때문에 `prototype` 프로퍼티가 없고 인스턴스도 생성하지 않습니다.

`ES6` 가 적용된 이후부터는 객체에 바인딩된 함수는 `메서드 축약 표현` 으로만 정의하기를 권장 합니다.



<br /><hr /><br />



# 3. 생성자 함수

`화살표 함수 (Arrow Function)` 은 기존의 `function 키워드` 대신 `간략한 함수 정의 방법` 입니다.

함수 정의 방법만 간략해 진 것이 아닌, `내부 동작` 도 간략해 졌습니다.



<br /><hr /><br />



## 3-1. 화살표 함수 정의

`화살표 함수` 는 함수 선언문으로 만들 수 없고, `함수 표현식` 으로만 정의할 수 있습니다.

또한 `매개변수가 1개` 일 때만 매개변수를 묶는 그룹 연산자인 `소괄호` 를 `생략` 할 수 있습니다.

그리고 `화살표 함수` 의 `몸체` 를 `블록 {}` 으로 묶지않고, `단일 표현식` 으로 만들 수 있습니다.

이렇게 만든 `화살표 함수` 는 암묵적으로 `표현식 결과값`을 `반환` 합니다.



<br /><hr /><br />



## 3-2. 화살표 함수와 일반 함수의 차이

화살표 함수와 일반 함수의 차이점은 다음과 같습니다.

* 화살표 함수는 `non-constructor` 함수 입니다.
* 화살표 함수는 함수 자체의 `this`, `arguments`, `super`, `new.target` 바인딩을 갖지 않습니다.
    * 화살표 함수에는 존재하지 않는 바인딩 이므로, 화살표 함수 내부에서 이러한 식별자를 참조하게 되면, `렉시컬 스코프` 에 의해 생성된 `스코프 체이` 에서 찾게 됩니다.
        * 이러한 동작에 의해 화살표 함수 내부의 `this` 는 `전역 객체` 가 아닌 `상위 스코프` 에 존재하는 `this` 가 됩니다.



<br /><hr /><br />



## 3-3. this

화살표 함수의 내부에는 `this 바인딩` 이 없습니다.

그래서 화살표 함수 내부에서 참조하는 `this` 는 `스코프 체인` 에서 찾게 되고, 가장 빨리 찾게되는 `상위 스코프의 this 바인딩` 을 참조하게 됩니다.

즉, `렉시컬 스코프` 를 통해서 `this` 를 참조하게 됩니다.

이러한 화살표 함수 내부의 `this` 참조 방식에 의해, `화살표 함수 내부의 this` 를 `Lexical This` 라고 합니다.



<br /><hr /><br />



## 3-4. super

`super` 키워드는 `메서드` 내부에서만 존재 합니다.

`화살표 함수` 내부에도 `super 바인딩` 은 없으며, 만약 화살표 함수 내부에서 `super` 를 참조하게 되면 `스코프 체인` 에서 `super 바인딩` 을 검색하게 됩니다.



<br /><hr /><br />



## 3-5. arguments

화살표 함수 내부에는 `arguments 바인딩` 도 없습니다.

마찬가지로 화살표 함수 내부에서 `arguments` 를 참조하게 되면, `스코프 체인` 에서 `arguments` 를 검색하게 됩니다.

하지만 이렇게 검색한 `arguments` 는 화살표 함수가 받은 `인수` 가 아닌, 상위 스코프에서 받은 `인수` 이므로, 활용도가 떨어집니다.



<br /><hr /><br />



# 4. Rest 파라미터

## 4-1. 기본 문법

`Rest 파라미터` 문법을 사용하면 함수에 넘겨주는 `파라미터 개수` 를 `가변` 으로 정의할 수 있으며, 특징은 다음과 같습니다.

* 전달받은 `Rest 파라미터` 는 `배열` 로 받게 됩니다.
* `Rest 파라미터` 는 반드시 마지막 파라미터로 정의해야 합니다.
* 하나의 함수에는 오직 1개의 `Rest 파라미터` 를 정의할 수 있습니다.



<br /><hr /><br />



## 4-2. Rest 파라미터와 arguments 객체

`arguments 객체` 는 함수에 넘겨준 `모든 인수` 가 담긴 `유사 배열 (array-like object)` 입니다.

`화살표 함수` 는 자신의 `arguments 객체` 를 갖지 않는 특징이 있습니다.

만약 `화살표 함수` 내부에서 `arguments` 참조를 하면 `스코프 체인` 에서 검색하게 되고, 이렇게 찾은 `arguments 객체` 는 `화살표 함수` 의 `인수 목록` 이 아닌, 자신이 정의된 홤수에서 받은 `인수 목록` 입니다.

그래서 `화살표 함수` 에서 `가변 길이 파라미터` 를 사용하고자 한다면, `Rest 파라미터` 를 사용해야 합니다.



<br /><hr /><br />



# 5. 매개변수 기본값

함수에 정의한 파라미터에 `인수` 를 넘겨주며 호출할 수 있습니다.

만약 `인수` 를 넘겨주지 않는다면 `undefined` 로 평가됩니다.

이렇게 `인수` 를 넘겨주지 않았을 때에 대한 `방어 코드` 로 `매개변수 기본값` 을 사용할 수 있습니다.

* 매개변수 기본값은 `Rest 파라미터` 에는 사용할 수 없습니다.
* `파라미터 기본값` 은 다음과 같은 경우에 적용 됩니다.
    * `인수` 를 넘겨주지 않았을 때
    * `인수` 에 `undefined` 를 넘겨주었을 때
