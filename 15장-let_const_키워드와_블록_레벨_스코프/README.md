# 15장. let, const 키워드와 블록 레벨 스코프

# 1. var 키워드로 선언한 변ㅅ누의 문제점

## 1-1. 변수 중복 선언 허용

`var` 키워드로 선언한 변수는 중복해서 선언이 가능 합니다.

`ES5` 이하 버전에서는 변수를 선언할 수 있는 유일한 방법이었는데, 여기에는 `초기화문` 의 `유무` 에 따라 `에러가 아닌`, `의도치 않은 동작` 을 하는 문제점이 있습니다.

```javascript
var x = "x 초기값";
var y = "y 초기값";

var x = 100;
var y;

console.log(x); // 100
console.log(y); // "y 초기값"
```

<br />

위 코드에서 `x` 와 `y` 는 중복 선언 되었습니다.

중복 선언하는 코드에서 `x` 는 `초기화문` 이 있지만, `y` 는 `초기화문` 이 없습니다.

이 때 발생하는 문제가, `y` 의 중복 선언의 결과가 `undefined` 가 아닌, `마지막에 할당된 값` 이 들어있게 되는 것 입니다.

* 중복 선언한 `var 키워드` 에 `초기화문` 이 없다면, 이 중복 선언은 `무시` 하게 됩니다.

<br />

이러한 현상에 의해, `y` 의 초기값은 우리가 의도했던 `undefined` 가 아닌, 어디선가 마지막에 할당했던 값이 `쓰레기값` 처럼 접근하게 됩니다.



<br /><hr /><br />



## 1-2. 함수 레벨 스코프

`var 키워드` 는 `함수 레벨 스코프` 로 동작 합니다.

그래서 `함수 외부` 의 `코드 블록` 에서 선언한 `var 변수` 는 `전역 변수` 가 되버립니다.

아래의 코드는 이러한 동작이 초래하는 `코드 블록` 내의 `var 변수` 예시 입니다.

```javascript
var i = 123;

for (var i = 0; i < 5; i++) {
  // do something...
}

console.log(i); // 5
```

<br />

`전역 변수` 로 선언한 `변수 i` 는 초기값으로 `123` 을 할당 하였습니다.

이후 `for 문` 에서 반복문의 상태값으로 `var i` 를 선언하여 사용한 후, `전역 변수` 인 `변수 i` 에는 `for 문` 에서 마지막에 할당했던 값으로 재할당 되는 문제가 발생 합니다.

<br />

이 현상에서 알 수 있듯이, `함수 레벨 스코프` 인 `var 키워드` 는 우리가 의도치 않게 변수를 `중복 선언` 하는 경우가 발생 합니다.



<br /><hr /><br />



# 1-3. 변수 호이스팅

`var 키워드` 로 선언한 변수는 `호이스팅` 에 의해 `스코프` 의 선두로 올려진 것처럼 동작합니다.

그래서 `var 변수` 를 선언하기 전에 접근 하여도 `오류 없이` 동작하게 됩니다.

이 현상은 `오류가 발생해야 정상` 이지만, `호이스팅` 에 의해, 코드 흐름과 맞지 않게 동작하게 되어 발생 합니다.

<br />

그러므로 `var 키워드` 로 선언한 변수는 `가독성` 을 떨어뜨리고, `버그` 의 여지를 남깁니다.



<br /><hr /><br />



# 2. let 키워드

## 2-1. 변수 중복 선언 금지

`let 키워드` 변수는 `중복 선언` 시에 `문법 에러` 를 발생 시킵니다.

그래서 `var 키워드` 처럼 의도치 않은 값이 들어있는 경우는 발생하지 않습니다.



<br /><hr /><br />



## 2-2. 블록 레벨 스코프

`let 키워드` 변수는 `블록 레벨 스코프` 를 따르므로, `코드 블록` 을 `스코프` 로 가지게 됩니다.



<br /><hr /><br />



## 2-3. 변수 호이스팅

자바스크립트의 `모든 선언문` 은 `호이스팅` 을 합니다.

다만 `ES6` 에 추가된 `let`, `const`, `class` 를 사용한 선언문은, 마치 `호이스팅` 되지 않는 것 처럼 동작하게 됩니다.

<br />

`호이스팅` 이 되지 않는 것 처럼 동작 하는 것은 다음과 같은 동작 입니다.

* 실제로는 `호이스팅` 동작을 합니다.
* `선언 단계` 와 `초기화 단계` 가 `분리` 되어 동작하게 됩니다.
* `호이스팅` 동작에서는 `선언 단계` 만 실행 됩니다.
* 이후, 코드 흐름상 `변수 선언문` 에 도달 했을 때, 비로소 `초기화 단계` 가 실행 됩니다.
* `초기화 단계` 가 실행되기 이전에, 이 변수에 접근하면 `참조 에러` 가 발생하게 됩니다.

<br />

정리하면, `호이스팅` 으로 동작은 하되, `초기화 단계` 만 실행되고, 실제 접근 가능한 시점은 코드 흐름상 `선언문` 에 도달한 이후가 됩니다.

이렇게 접근 불가능한 구간을 `일시적 사각지대 (TDZ: Temporal Dead Zone)` 이라고 합니다.



<br /><hr /><br />



## 2-4. 전역 객체와 let

`var 키워드` 나 `function`, `암묵적 선언 (선언하지 않은 변수에 할당)` 하는 방식은 `전역 객체` 인 `window` 의 프로퍼티가 되었습니다.

`let 키워드` 를 `전역 스코프` 에서 선언하게 되면, 이 변수는 `window` 의 프로퍼티가 되지 않습니다.

그래서 `window` 객체를 통해 접근할 수 없습니다.

그렇다고 존재하지 않는 것은 아니고, `보이지 않는 블록` 내에 존재하게 됩니다.



<br /><hr /><br />



# 3. const 키워드

## 3-1. 선언과 초기화

`const 키워드` 로 선언한 변수는 반드시 `선언` 과 `초기화` 를 `동시에` 해야 합니다.

그리고 `let 키워드` 처럼, `블록 레벨 스코프` 로 동작하며, `호이스팅` 이 발생하지 않는 것 처럼 동작 합니다.



<br /><hr /><br />



## 3-2. 재할당 금지

`const 키워드` 로 선언한 변수는, 반드시 `초기화` 를 해야하며, 이후에 `재할당` 을 할 수 없습니다.



<br /><hr /><br />



## 3-3. 상수

`const 키워드` 로 선언한 변수는 `재할당` 이 `금지` 되어 있습니다.

그래서 `const 변수` 에 `원시값` 을 `초기값` 으로 할당하게 되면, `상수` 라는 의미로 표현할 수 있습니다.



<br /><hr /><br />



## 3-4. const 키워드와 객체

`const 변수` 에 `객체` 를 할당하는 경우, 이 객체의 프로퍼티를 `생성`, `삭제`, `재할당` 은 할 수 있습니다.

이는 `const 변수` 의 `초기값` 으로 `객체의 참조값` 이 들어있을 뿐, `객체` 내부를 조작하는 것은 `객체의 참조값` 에는 영향을 주지 않기 때문입니다.

그래서 `const 변수` 에 `객체` 를 할당 하였다고 해도, 이 `const 변수` 가 참조하는 `객체` 가 `불변성` 을 갖지는 않습니다.

즉,`const 변수` 의 `참조값` 만 `재할당 금지` 를 할 뿐, `실제 객체` 는 자유롭게 변경할 수 있습닌다.



<br /><hr /><br />



# 4. var vs. let vs. const

`ES6` 이상 버전을 사용한다면, `var` 키워드는 사용하지 않도록 합니다.

그러므로 `let` 과 `const` 키워드로만 변수를 선언하며, `재할당` 이 필수인 경우를 제외하면, `const 키워드` 로 변수를 선언하는 것을 권장 합니다.
