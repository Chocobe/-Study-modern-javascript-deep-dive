# 14장. 전역 변수의 문제점

# 1. 변수의 생명 주기

## 1-1. 지역 변수의 생명 주기

변수는 자신이 선언된 위치에서 `생성` 되고 `소멸` 합니다.

만약 `전역 변수` 를 선언했다면, 애플리케이션이 실행될 때 `생성` 되고 종료될 때 `소멸` 하게 됩니다.

이와 같이 `지역 변수` 는 함수가 실행될 때 `생성` 되고 종료될 때 `소멸` 하게 됩니다.

<br />

`일반적` 으로 `지역 변수의 생명주기` 는 `함수의 생명주기` 와 `일치` 하지만, 변수의 생명주기를 `스코프` 까지 확장하여 본다면, `지역변수` 가 `함수` 보다 `오래 생존` 할 수도 있습니다.

이는 함수가 종료 되었지만, 해당 `스코프` 가 `생존` 한 상황일 때 입니다.

더 정확한 `변수의 생명주기` 는 `스코프의 생명주기` 와 `일치` 한다는 것 입니다.

* 참고로 `스코프` 가 생성될 때, 이 스코프 내부의 `모든 선언문` 을 먼저 실행하는 `호이스팅` 은 `스코프 단위` 로 동작하게 됩니다.

<br />

`스코프의 생명주기` 는 `함수` 가 `실행` 될 때 함께 `생성` 되지만, `소멸` 은 함수의 종료와 일치하지 않을 수 있습니다.

함수는 종료되었지만, 이 `스코프` 를 어디선가 `참조하고 있다면`, 함수가 소멸하여도 `스코프` 는 그대로 생존하게 됩니다.

즉, `스코프` 의 `소멸` 은 아무도 참조하고 있지 않을 때가 됩니다.

이렇게 `스코프` 가 생존하고 있다면, 이 `스코프의 지역 변수` 도 `생존` 하게 됩니다.



<br /><hr /><br />



## 1-2. 전역 변수의 생명 주기

전역 코드는 해당 코드를 `로드 직후` 실행 됩니다.

`브라우저` 환경에서의 전역 객체는 `window` 이므로, `var 키워드` 로 선언한 `전역 변수` 는 `window` 의 `프로퍼티` 가 됩니다. (ES6 이전 버전)

이렇게 선언한 `전역 변수` 는 전역 객체인 `window` 가 소멸할 때 함께 소멸하므로, 해당 웹페이지의 생명주기와 `일치` 하게 됩니다.



<br /><hr /><br />



# 2. 전역 변수의 문제점

전역 변수를 사용하는 것은 많은 문제점을 가집니다.

아래 4가지는 전역 변수를 사용할 때 직면하게 되는 문제점 입니다.

* 암묵적 결합
  * `전역 변수` 는 코드 어디서든 `참조` 할 수 있고, `할당` 할 수 있는데, 이를 `암묵적 결합 (Implicit Coupling)` 이라고 합니다.
  * 변수의 `유효 범위` 가 클수록 코드의 가독성이 나빠지고, 의도치 않은 `재할당` 이 발생하는 위험성도 커집니다.

* 긴 생명주기
  * `전역 변수` 의 생명주기는 애플리케이션의 생명주기와 동일합니다.
  * 애플리케이션이 종료하기 전까지 `전역 변수` 가 할당된 메모리는 계속 소비하게 됩니다.

* 스코프 체인 상의 종점에 존재
  * `전역 변수` 는 가장 말단의 스코프에 위치하므로, `전역 변수` 를 검색하는 속도가 가장 느립니다.

* 네임스페이스 오염
  * 자바스크립트는 파일이 분리되어 있더라도, `하나의 전역 스코프` 를 `공유` 합니다.
  * 모든 파일에서 참조하는 `전역 변수` 에 `재할당` 이 발생하면, `재할당` 이 발생한 위치를 디버깅 하기는 매우 어렵습니다.



<br /><hr /><br />



# 3. 전역 변수의 사용을 억제하는 방법

위에서 살펴본 것 처럼 `전역 변수` 는 많은 문제점을 가지고 있습니다.

그래서 `변수` 는 `스코프` 가 `좁을수록` 좋으며, 특별한 이유가 없다면 `전역 변수` 는 피하는 것이 좋습니다.



<br /><hr /><br />



## 3-1. 즉시 실행 함수

모든 코드를 `즉시 실행 함수` 로 감싸면, 하나의 거대한 `함수 스코프` 가 됩니다.

그러므로, 여기에 포함된 `모든 전역 변수` 는 `즉시 실행 함수` 의 `지역 변수` 가 됩니다.

이 방법은 `전역 변수` 를 생성하지 않게 되므로, `라이브러리` 에서 자주 사용됩니다.



<br /><hr /><br />



## 3-2. 네임스페이스 객체

전역에 `네임스페이스` 역할의 객체를 만들고, 이 객체의 프로퍼티와 메서드를 사용하는 방법 입니다.

하지만 `네임스페이스` 역할의 객체 자체가 `전역 변수` 이므로, 유용하지 않습니다.



<br /><hr /><br />



## 3-3. 모듈 패턴

`객체지향 프로그래밍 언어` 에서 제공하는 `class` 처럼, 자바스크립트의 `클로저 (Closure)` 를 사용하여 `캡슐화` 하는 방법 입니다.

자바스크립트에는 `객체지향 프로그래밍 언어` 의 `접근 한정자` 기능은 없지만, `클로저 (Closure)` 특성으로 `public` 과 `private` 을 구현할 수 있습니다.

```javascript
const Counter = (function() {
  let count = 0;

  const increase = () => ++count;
  const decrease = () => --count;
  const getCount = () => count;

  return {
    increase,
    decrease,
    getCount,
  };
}());

console.log(Counter.getCount()); // 0

Counter.increase();
console.log(Counter.getCount()); // 1

Counter.decrease();
Counter.decrease();
console.log(Counter.getCount()); // -1
```



## 3-4. ES6 모듈

`ES6 모듈` 을 사용하면 더이상 전역 변수를 사용할 수 없습니다.

`ES6 모듈` 은 `파일 자체` 를 `스코프` 로 제공하기 때문 입니다.

그래서 `ES6 모듈` 을 사용할 때의 모든 변수는 `전역 변수` 가 아닌 `지역 변수` 로 선언되고, 더이상 `window 전역 객체` 의 프로퍼티가 되지도 않습니다.

<br />

브라우저에서 제공하는 `ES6 모듈` 방식을 사용하기 위해서는 `<script />` 태그의 `속성 (Attribute)` 에 `type="module"` 을 추가해 주면 됩니다.

* `<script type="module" />` 을 사용한다면, `.mjs` 확장자를 권장 합니다.

```html
<script type="module" src="./index.mjs"></script>
<script type="module" src="./app.mjs"></script>
<script type="module" src="./lib.mjs"></script>
```

<br />

하지만 아직까지는 `Webpack` 같은 `모듈 번들러` 를 통해 `ES6 모듈` 을 사용합니다.
