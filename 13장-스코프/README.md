# 13장. 스코프

## 1. 스코프란?

`스코프 (Scope)` 는 `유효범위` 를 말합니다.

정의한 변수나 함수 등, `모든 식별자` 를 참조할 수 있는 유효한 범위를 말할 때, `스코프 (Scope)` 라고 표현 합니다.

그러므로, `스코프 (Scope)` 는 `식별자` 가 유효한 범위를 말합니다.

<br />

아래의 코드에서 `변수 x` 는 서로 다른 스코프에 같은 이름으로 사용하고 있습니다.

```javascript
var x = "global";

function myFunc() {
  var x = "local";
}

myFunc(); // "local"
console.log(x); // "global"
```

<br />

`myFunc()` 을 호출하였을 때 사용하는 `x` 에는 `"local"` 값이 들어있는 변수가 사용 되었습니다.

그리고 함수 밖에서 호출한 `console.log(x)` 에는 `"global"` 값이 들어있는 변수가 사용되었습니다.

이렇게 `스코프가 다르지만 이름은 동일한 변수` 를 사용할 때, 자바스크립트 엔진은 어떤 변수를 참조할 것인지를 결정해야 합니다.

`스코프` 는 자바스크립트 엔진이 `식별자를 검색할 때 사용하는 규칙` 으로 사용합니다.

<br />

위에서 살펴본 `스코프 (Scoped)` 의 개념은 컴퓨터의 `폴더 구조` 와 유사합니다.

동일한 폴더에 동일한 파일명을 만들 수는 없지만, 폴더가 다르다면 파일명은 동일하게 만들 수 있습니다.

그리고 우리가 실행하는 파일은 현재 폴더 내에서 파일명 으로 참조하게 됩니다.

자바스크립트 엔진 역시, 현재 `스코프 (Scope)` 내에서 `식별자` 를 참조하고, 없다면, `상위 스코프` 에서 `식별자` 를 찾게 됩니다.

* 만약 대상 식별자가 최상위 스코프까지 존재하지 않는다면, `ReferenceError` 가 발생합니다.

<br />

그리고 변수를 선언할 때 `var` 키워드로 만든다면, 같은 스코프 내에서 `중복 선언` 을 허용하므로, `var` 키워드 대신 `const` 나 `let` 으로 변수 선언하는 것을 권장 합니다.



<br /><hr /><br />



# 2. 스코프의 종류

스코프는 범위에 따라 두가지로 구분할 수 있습니다.

* 전역 스코프
* 지역 스코프



<br /><hr /><br />



## 2-1. 지역과 지역 스코프

`전역 스코프` 는 코드의 `가장 바깥 영역` 을 말합니다.

`지역 스코프` 는 `함수 내부` 영역을 말합니다.

<br />

`전역 스코프` 는 모든 영역에서 해당 식별자를 참조할 수 있지만, `지역 스코프` 는 자신의 스코프 내부와 해당 `지역 스코프` 의 `하위 스코프` 에서만 식별자를 참조할 수 있습니다.

`전역 스코프` 와 `지역 스코프` 에 동일한 이름의 식별자가 있다면, 현재 실행중인 `스코프` 에서 먼저 식별자를 찾고, 없다면 상위 스코프에서 찾는 방식으로 동작 합니다.

즉, 자바스크립트 엔진은 `스코프 체인` 을 통해서 `참조할 변수를 검색` 하게 됩니다.



<br /><hr /><br />



# 3. 스코프 체인

아래 코드처럼 함수 내부에 또다른 함수를 정의할 수 있습니다.

이렇게 내부에 있는 함수는 `중첩 함수` 라고 하며, `중첩 함수` 가 정의된 바깥 함수를 `외부 함수` 라고 합니다.

<br />

스코프의 관점에서 본다면, `외부 함수의 스코프` 안에 `중첩 함수의 스코프` 가 중첩된 형태가 됩니다.

이렇듯 `스코프` 는 중첩된 형태의 `계측적 구조` 를 갖게 됩니다.

<br />

그리고 `중첩 스코프` 를 기준으로 `외부 함수의 스코프` 를 가리켜 `상위 스코프` 라고 합니다.

<br />

자바스크립트는 1개의 `전역 스코프` 안에 다양한 깊이로 `스코프` 가 중첩되어 `계층적으로 연결` 되어 있는데, 이를 `스코프 체인 Scope Chain)` 이라고 합니다.

정리하면, 자바스크립트는 1개의 `전역 스코프` 에 구성된 `스코프 체인 (Scope Chain)` 에서 `식별자` 를 검색하는 방식으로 동작합니다.



<br /><hr /><br />



## 3-1. 스코프 체인에 의한 변수 검색

`스코프 체인` 을 통해 `식별자를 검색` 할 때, `현재 스코프` 에서 `상위 스코프` 방향으로 `식별자` 를 찾았습니다.

이는 `현재 스코프` 가 `상위 스코프` 를 `상속 (Inherit)` 받는 형태와 유사합니다.

그래서 `식별자` 를 검색할 때, `현재 스코프` 에서 `하위 스코프` 방향으로 찾는 경우는 존재하지 않습니다.



<br /><hr /><br />



## 3-2. 스코프 체인에 의한 함수 검색

`식별자` 를 검색하기 위한 `스코프 체인 (Scope Chain)` 에 의해, 아래 코드의 `inner()` 함수에서 참조하는 `변수 x` 는 `inner X` 값을 참조하게 됩니다.

```javascript
var x = "global X";

function outerFunc() {
  var x = "outer X";

  function innerFunc() {
    var x = "inner X";
  }

  innerFunc();
}

outerFunc(); // "inner X"
```



<br /><hr /><br />



# 4. 함수 레벨 스코프

`var` 키워드로 선언된 변수는 `함수 레벨 스코프 (Function Level Scope)` 입니다.

이는 `var` 키워드는 `함수 스코프` 만을 지원하기 때문에, `if()` 나 `for()` 문과 같은 `블록 레벨` 에 대해서는 `스코프` 를 만들지 않습니다.

그래서 아래의 코드에서 사용한 `변수 x` 는 모두 같은 변수를 참조하게 됩니다.

즉, `if() 문` 에서 선언한 `변수 x` 는 `중복 선언` 된 변수 입니다.

```javascript
function myFunctionLevelScope() {
  var x = "initial Value";

  if (true) {
    var x = "altered value from if() block";
  }

  console.log(x); // "altered value from if() block"
}

myFunctionLevelScope();
```

<br />

일반적인 프로그래밍 언어에서는 `블록 레벨 스코프 (Block Level Scope)` 로 동작합니다.

`if문`, `for문` 처럼 `블록 레벨 (Block Level)` 을 `내부 스코프` 로 생성하는 방식으로 동작합니다.

그래서 자바스크립트에도 `let` 과 `const` 키워드를 제공하게 되었고, 이 키워드를 사용하게 되면 `블록 레벨 스코프 (Block Level Scope)` 로 동작하게 됩니다.

```javascript
function myBlockLevelScope() {
  let x = "initial Value";

  if (true) {
    let x = "altered value from if() block";
  }

  console.log(x); // "initial Value"
}

myBlockLevelScope();
```



# 5. 렉시컬 스코프

함수는 `정의된 곳` 을 `상위 스코프` 로 `기억` 합니다.

자바스크립트 뿐만 아니라, 일반적인 프로그래밍 언어의 `스코프` 동작 방식 입니다.

<br />

이렇게 `정의된 곳` 을 기준으로 `상위 스코프` 가 결정되는 방식을 `렉시컬 스코프 (Lexical Scope)` 또는 `정적 스코프 (Static Scope)` 라고 합니다.

<br />

자바스크립트는 프로그램을 실행할 때, `정의` 를 먼저 실행하는 `호이스팅 (Hoisting)` 방식으로 동작합니다.

`호이스팅 (Hoisting)` 으로 실행되는 시점에서 `함수 정의` 가 실행되게 되는데, 이 때 `함수의 상위 스코프` 를 기억하게 되며, 이 함수를 호출할 때마다 `기억했던 상위 스코프` 를 참조하게 됩니다.

<br />

정리하면, 함수의 `상위 스코프` 는 `함수 정의가 된 스코프` 가 되며, 호출 위치에는 영향을 받지 않으며, 이렇게 동작하는 `스코프 방식` 을 `렉시컬 스코프 (Lexical Scope)` 또는 `정적 스코프 (Static Scope)` 라고 합니다.

```javascript
var x = 1;

function firstFunc() {
  var x = 10;

  secondFunc();
}

function secondFunc() {
  console.log(x);
}

firstFunc(); // 1
secondFunc(); // 1
```
