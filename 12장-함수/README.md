# 12장. 함수

# 1. 함수란?

함수는 `입력 (Input)` 을 받아서 `출력 (Output)` 하는 과정을 정의한 것입니다.

이를 다르게 표현하면, `출력 (Output)` 을 위한 모든 과정을 `코드 블록` 으로 감싼, `하나의 실행 단위` 를 정의한 것을 `함수` 라고 합니다.



<br /><hr /><br />



# 2. 함수를 사용하는 이유

동일한 작업을 여러번 수행해야 할 경우, 반복되는 작업을 함수로 만들어서 재사용할 수 있습니다.

이렇게 함수로 분리하게 되면, 다음과 같은 장점을 얻을 수 있습니다.

* 유지보수의 편의성
* 코드의 신뢰성
* 코드의 가독성 향상



<br /><hr /><br />



# 3. 함수 리터럴

`함수 리터럴` 은 함수를 생성하는 방법 중 하나 입니다.

`함수 리터럴` 은 `함수명의 유무` 에 따라 나눌 수 있습니다.

* `무명 함수 리터럴`
* `기명 함수 리터럴`

<br />

```javascript
// 무명 함수 리터럴 => myFunc 변수에 할당
const myFunc = function(a, b) {
  return a - b;
};

console.log(myFunc(10, 3)); // 7

// 기명 함수 리터럴
function sub(a, b) {
  return a - b;
}
```



<br /><hr /><br />



# 4. 함수 정의

함수를 생성하기 위한 작업을 `함수 정의` 라고 합니다.

위에서 살펴보았던 `함수 리터럴` 도 `함수 정의` 중 하나 입니다.

<br />

아래는 `함수 정의` 방법 4가지 입니다.

* 함수 선언문
* 함수 표현식
* Function 생성자 함수
* 화살표 함수



<br /><hr /><br />



## 4-1. 함수 선언문

자바스크립트의 `중괄호 {}` 는 `중의적 표현` 입니다.

`중괄호 {}` 는 두가지 경우에서 사용합니다.

* 객체 리터럴: 값으로 평가되는 `표현식` 입니다.
* 블록문: `표현식이 아닌 문` 입니다.

<br />

`블록문` 은 값으로 평가되지 않기 때문에, `블록문` 을 변수에 할당하면, 변수는 `undefined` 가 됩니다.

<br />

`함수 선언문` 은 `기명 함수 리터럴` 과 동일하며, 여기에 사용한 `중괄호 {}` 는 `블록문` 으로써 사용됩니다.

```javascript
function add(a, b) {
  return a + b;
}
```

<br />

`함수 선언문` 은 `블록문` 이기 때문에, 실행 결과를 변수에 대입하면 `undefined` 가 될 것으로 기대하지만, `함수 선언문` 을 변수에 할당하게 되면, 변수에는 `함수 참조값` 이 저장되게 됩니다.

이는 `중괄호 {}` 가 `중립적 표현` 이며, `함수 선언문` 을 `블록문` 이 아닌 `객체 리터럴` 로 해석하기 때문입니다.

<br />

즉 `함수 선언문 (=== 기명 함수 리터럴)` 을 `피연산자` 로 사용하게 되면, `객체 리터럴 표현식` 이 됩니다.

```javascript
function add(a, b) {
  return a + b;
}

console.log(add(1, 2)); // 3

const subRef = function sub(a, b) {
  return a - b;
};

console.log(subRef(10, 3)); // 7
```



<br /><hr /><br />



## 4-2. 함수 표현식

함수는 `객체` 입니다.

그래서 `값` 으로 사용할 수 있으며, `함수 리터럴` 로 생성하여 변수에 할당할 수 있습니다.

이렇게 `함수 리터럴` 로 생성한 함수를 `변수에 할당` 하는 `함수 정의` 방식을 `함수 표현식` 이라고 합니다.

```javascript
// 무명 함수 표현식
const add = function(a, b) {
  return a + b;
};

console.log(add(1, 2)); // 3

// 기명 함수 표현식
const sub = function _sub(a, b) {
  return a - b;
};

console.log(sub(10, 7)); // 3
```



<br /><hr /><br />



## 4-3. 함수 생성 시점과 함수 호이스팅

자바스크립트의 `모든 선언문` 은 `런타임 이전` 에 자바스크립트 엔진에 의해 `먼저 실행` 됩니다.

`함수 선언문` 도 `선언문` 이므로, `런타임 이전` 에 `먼저 실행` 됩니다.

그래서 아래 코드처럼 `함수 선언문` 이전에 호출하여도 정상적으로 호출할 수 있습니다.

```javascript
console.log(add(1, 2)); // 3

function add(a, b) {
  return a + b;
}
```

<br />

만약 `함수 표현식` 에 적용할 경우, `함수 표현식` 이전에 함수를 호출하면, `타입 에러` 가 발생하게 됩니다.

```javascript
console.log(add(1, 2)); // Error 발생

const add = function(a, b) {
  return a + b;
};
```

<br />

이는 `함수 선언문 초기화` 와 `변수 선언 초기화` 의 동작이 달라서 발생하는 현상 입니다.

`함수 선언문 초기화` 는 `함수 객체` 로 초기화가 됩니다.

반면 `변수 선언 초기화` 는 `undefined` 로 초기화가 됩니다.

이러한 초기화 동작 차이에 의해, `함수 표현식` 은 반드시 `함수 표현식이 호출된 이후` 에 사용할 수 있습니다.

<br />

위에서 언급했던 `함수 선언문` 이전에 해당 함수를 호출할 수 있는 현상을 `함수 호이스팅` 이라고 합니다.

그리고 `함수 표현식` 은 `변수 초기화` 방식으로 동작하게 되기 때문에 `undefined` 로 초기화가 되므로, `함수 표현식` 이후에만 호출할 수 있게 됩니다.



<br /><hr /><br />



## 4-4. Function 생성자 함수

함수를 정의하기 윈한 방법중, `빌트인 함수` 인 `Function` 으로도 함수를 정의할 수 있습니다.

```javascript
const add = new Function('a', 'b', 'return a + b');
console.log(add(10, 20)); // 30
```

<br />

`함수 선언문` 이나 `함수 표현식` 과는 큰 차이점을 가지는데, `클로저 (Closure)` 를 생성하지 않는 것 입니다.

때문에 일반적으로 `Function 생성자 함수` 는 권장하지 않는 방식의 `함수 정의` 입니다.



<br /><hr /><br />



## 4-5. 화살표 함수

`화살표 함수` 도 `함수 정의` 방법중 하나 입니다.

하지만 지금까지 살펴본 `function` 키워드로 정의한 함수와는 내부 동작에서 차이점이 있습니다.

아래 요소들은 `화살표 함수` 특징 입니다.

* `Function 생성자 함수` 로는 사용 불가능 합니다.
* `this` 바인딩이 다릅니다.
* `prototype` 프로퍼티가 없습니다.
* `arguments` 객체를 생성하지 않습니다.



<br /><hr /><br />



# 5. 함수 호출

`함수 정의` 로 만들어진 함수는 `함수 호출` 을 통해, `함수 몸체의 문들` 을 실행 합니다.

함수를 호출하면, 호출 지점의 실행 흐름은 중지한 후, 호출한 `함수 몸체의 문들` 을 실행하고, 해당 문들을 모두 실행한 후, 정지했던 지점부터 실행을 재개 합니다.



<br /><hr /><br />



## 5-1. 매개변수와 인수

함수를 실행할 때, 함수 내부에서 사용할 값을 넘겨줄 수 있습니다.

이렇게 넘겨줄 값은 `함수 정의` 에서 함께 정의하게 되는데, 이를 `매개변수 또는 인자 (Parameter)` 라고 합니다.

그리고 실제 `함수 호출` 시점에 실제로 넘겨주는 값을 `인수 (Argument)` 라고 합니다.

```javascript
// 매개변수: x, y
function add(x, y) {
  return x + y;
}

// 인수: 1, 2
add(1, 2);
```

<br />

`매개변수` 는 `함수 정의` 에서 정의한 개수와 일치하지 않아도 실행 자체에는 문제가 없습니다.

만약 정의된 `매개변수` 에 `인수` 를 넘겨주지 않았다면, 해당 `인수` 는 `undefined` 가 됩니다.

<br />

그리고 정의한 `매개변수` 개수를 초과하는 `인수` 를 넘겨주게 되면, 초과한 `인수` 는 `매개변수` 로 접근만 못하며 실행 자체에는 문제가 없습니다.

이렇게 초과한 `인수` 도 접근할 수 있는 방법이 있습니다.

함수의 모든 `매개변수` 는 함수 내부에서 `arguments` 객체로 접근할 수 있으므로, `arguments 객체` 를 통해서 `매개변수` 개수를 초과한 `인수` 도 접근할 수 있습니다.

```javascript
function doSome(name, age) {
  console.log(arguments);
}

doSome("Chocobe", 36, "FrontEnd");
// [Arguments] { '0': 'Chocobe', '1': 36, '2': 'FrontEnd' }
```



<br /><hr /><br />



## 5-2. 인수 확인

자바스크립트는 동적 타입 언어 입니다.

때문에 함수에 넘겨주는 `인수` 의 `타입` 이나 `개수` 가 일치하는지 검사하지 않습니다.

만약 `인수` 의 `타입 검사` 를 하고 싶다면, `typeof` 키워드를 사용하여, 타입 단언을 할수 있으며, `인수의 기본값` 을 지정하는 방법으로 `인수 개수` 를 일치 시킬수도 있습니다.

```javascript
function add(x, y) {
  if (!(typeof x !== 'number') || !(typeof y !== 'number')) {
    throw new TypeError("number 타입 인수가 필요합니다.");
  }

  return x + y;
}
console.log(1, 2); // 3

function div(x, y = 1) {
  return x / y;
}
console.log(div(10)); // 10
```



<br /><hr /><br />



## 5-3. 매개변수의 최대 개수

`매개변수` 는 순서에 의미를 가집니다.

두개의 `매개변수` 에 넘겨준 `인수` 의 순서가 바뀔경우, 함수의 결과가 달라질 수 있습니다.

그래서 `매개변수` 는 `최대 3개` 까지를 권장 합니다.

<br />

만약 `매개변수` 개수가 3개를 초과할 경우, `객체` 를 `인수` 로 넘겨주는 방식으로 `매개변수` 의 개수를 줄일 수 있습니다.

`객체 인수` 는 `키: 값` 으로 객체를 구성하기 때문에, 가독성이 좋아지고 실수도 줄일 수 있습니다.

주의할 점은, `인수` 로 넘겨준 `객체` 를 함수 내부에서 변경하게 되면, 함수 외부에도 반영이 되는 `부수효과 (Side Effect)` 가 발생하게 됩니다.



<br /><hr /><br />



## 5-4. 반환문

`함수 호출` 은 `표현식` 입니다.

즉, `함수 호출` 결과를 `값` 으로 평가하게 되며, 이렇게 반환하는 값은 함수 내부의 `return` 으로 내보낼 수 있습니다.

<br />

함수의 `return` 은 두가지 기능이 있습니다.

* `return` 실행 후, 함수를 종료 합니다.
* `return` 의 우측에 사용한 `표현식` 을 함수 외부로 내보냅니다.



# 6. 참조에 의한 전달과 외부 상태의 변경

`매개변수` 에 `객체 인수` 를 넘겨주게 되면, `참조값` 을 넘겨주게 됩니다.

`객체 인수` 를 함수 내부에서 변경하여 발생하는 `부수효과 (Side Effect)` 는, 값이 변경되는 위치를 파악하기 어렵게 하기 때문에, `객체 인수` 를 `불변 객체 (Immutable Object)` 로 만들거나, `깊은 복사 (Deep copy)` 를 하여 넘겨주는 방법으로 `부수효과 (Side Effect)` 를 방지할 수 있습니다.

<br />

이렇게 만든 함수는 함수의 실행 자체가 외부에 영향을 미치지 않게 되는데, 이러한 함수를 `순수 함수 (Pure Function)` 라고 합니다.



<br /><hr /><br />



# 7. 다양한 함수의 형태

## 7-1. 즉시 실행 함수

`즉시 실행 함수 (Immediately Invoked Function)` 은 `함수 정의` 와 동시에 `호출` 하는 함수 입니다.

이렇게 딱 한번 호출된 `즉시 실행 함수 (Immediately Invoked Function)` 은 다시는 호출할 수 없는 특징을 가집니다.

```javascript
(function() {
  console.log("Hello World");
}());
```

<br />

위 코드에서 `함수 선언문` 을 `그룹 연산자 ()` 로 묶었습니다.

이유는 다음과 같습니다.

* `함수 선언문` 은 `기명 함수 리터럴` 로 만들 수 있기 때문에, `함수명` 을 생략할 수 없습니다.
* 함수의 몸체인 `블록문 {}` 뒤에 오는 `소괄호 ()` 를 `그룹 연산자 ()` 로 해석하기 때문에, 자바스크립트 문법에 맞지 않게 됩니다.
* `그룹 연산자 ()` 안에 위치한 `무명 함수 리터럴` 은, 먼저 `함수 리터럴` 로 평가하게 되고, 이후 `함수 호출 ()` 로 해석하게 됩니다.



<br /><hr /><br />



## 7-2. 재귀 함수

`재귀 함수 (Recursive Function)` 은 자기 자신을 호출하는 함수 입니다.

아래 코드는 1 부터 10까지 반복문을 사용하지 않고, `재귀 함수` 로 구현한 예시 입니다.

```javascript
function myPrint(num) {
  if (num < 1) return;

  console.log(num);
  myPrint(num - 1);
}

myPrint(10);
```



<br /><hr /><br />



## 7-3. 중첩 함수

함수 내부에 정의한 함수를 `중첩 함수` 또는 `내부 함수` 라고 합니다.

그리고 `중첩 함수` 가 정의된 함수를 `외부 함수` 라고 합니다.

`중첩 함수` 는 오직 `외부 함수` 를 돕기 위한 목적으로 만들며, `헬퍼 함수 (Helper Function)` 역할을 합니다.



<br /><hr /><br />



## 7-4. 콜백 함수

함수에는 `매개변수` 에 값을 넘겨줄 수 있습니다.

`함수` 또한 `객체 타입` 값이므로, 함수의 `매개변수` 로 넘겨줄 수 있습니다.

이렇게 `매개변수` 로 넘겨주는 `함수` 를 `콜백 함수 (Callback Function)` 이라고 합니다.

<br />

이렇게 `콜백 함수` 를 전달받는 함수는 `고차 함수 (HOF: Higher-Order Function)` 이라고 합니다.

`콜백 함수` 도 `내부 함수` 처럼 `헬퍼 역할` 을 하게 되는데, `고차 함수 (HOF: Higher-Order Function)` 를 돕게 됩니다.

<br />

아래는 `콜백 함수` 와 `고차 함수` 를 사용한 예시 입니다.

```javascript
// HOF
function repeat(value, callback) {
  for (let i = 0; i < value; i++) {
    callback(i);
  }
}

// Callback 1
function print(value) {
  console.log(value);
}
repeat(5, print);

// Callback 2
function printOdd(value) {
  if (value % 2 === 1) console.log(value);
}
repeat(5, printOdd);
```

<br />

위 예시 코드처럼 `콜백 함수` 는 `고차 함수` 에 의해서 호출 되며, 결과적으로 `고차 함수` 가 `콜백 함수` 를 자신의 일부분으로 `합성` 하게 됩니다.



<br /><hr /><br />



## 7-5. 순수 함수와 비순수 함수

함수는 `순수 함수 (Pure Function)` 과 `비순수 함수 (Impure Function)` 으로 구분할 수 있습니다.

<br />

`순수 함수` 는 다음과 같은 특징을 가집니다.

* 동일한 인수를 전달하면, 동일한 결과를 반환합니다.
* 오직 매개변수로 전달받은 `인수` 에만 `의존` 하여 값을 반환 합니다.
* 함수의 `외부 상태` 를 변경하지 않습니다.
  * `외부 상태` 에 의존성을 갖지 않습니다.

<br />

아래 코드는 순수 함수의 예시 입니다.

```javascript
let count = 0;

function increase(value) {
  return ++value;
}

console.log(count); // 0

increase(count);
console.log(count); // 1

increase(count);
console.log(count); // 2
```

<br />

`순수 함수` 를 만들고자 할 때 주의할 점은, `매개변수` 로 `객체` 를 받아서는 안됩니다.

`인수` 로 `객체` 를 넘겨주게 되면, 함수 내부에서 `인수 객체` 의 `프로퍼티 값` 을 변경할 수 있게 되고, 이는 함수 `외부 상태` 에 영향을 미치게 됩니다.

즉, `객체 인수` 를 받게 되면 `외부 상태` 에 의존성을 갖게 되므로, `비순수 함수` 가 됩니다.

<br />

`순수 함수` 가 아닌 함수는 `비순수 함수 (Impure Function)` 으로 볼 수 있습니다.

`순수 함수` 의 조건중 단 하나라도 맞지 않다면, `비순수 함수` 가 됩니다.

<br />

`순수 함수` 로 구성된 프로그램은 `상태값` 의 변경 위치를 명확히 알 수 있습니다.

이를 모토로 하는 프로그래밍 패러다임으로 `함수형 프로그래밍` 이 있습니다.

<br />

`함수형 프로그래밍` 은 `순수 함수` 와 `보조 함수` 의 조합으로 `부수 효과 (Side Effect)` 를 최소화하고, `불변성 (Immutable)` 을 지향합니다.

그리고 `함수형 프로그래밍` 으로 개발하게 되면 다음과 같은 코드 구조를 갖게 됩니다.

* 로직 내의 `반복문` 과 `조건문` 을 사용하지 않게 됩니다.
  * 코드 복잡성 해결
* 변수 사용을 억제할 수 있고, 생명주기를 최소화 할 수 있습니다.
  * 로직내의 상태값 변경에 의한 오류를 피할 수 있게 됩니다.