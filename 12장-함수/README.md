# 12장. 함수

# 1. 함수란?

함수는 `입력 (Input)` 을 받아서 `출력 (Output)` 하는 과정을 정의한 것입니다.

이를 다르게 표현하면, `출력 (Output)` 을 위한 모든 과정을 `코드 블록` 으로 감싼, `하나의 실행 단위` 를 정의한 것을 `함수` 라고 합니다.



<br /><hr /><br />



# 2. 함수를 사용하는 이유

동일한 작업을 여러번 수행해야 할 경우, 반복되는 작업을 함수로 만들어서 재사용할 수 있습니다.

이렇게 함수로 분리하게 되면, 다음과 같은 장점을 얻을 수 있습니다.

* 유지보수의 편의성
* 코드의 신뢰성
* 코드의 가독성 향상



<br /><hr /><br />



# 3. 함수 리터럴

`함수 리터럴` 은 함수를 생성하는 방법 중 하나 입니다.

`함수 리터럴` 은 `함수명의 유무` 에 따라 나눌 수 있습니다.

* `무명 함수 리터럴`
* `기명 함수 리터럴`

<br />

```javascript
// 무명 함수 리터럴 => myFunc 변수에 할당
const myFunc = function(a, b) {
  return a - b;
};

console.log(myFunc(10, 3)); // 7

// 기명 함수 리터럴
function sub(a, b) {
  return a - b;
}
```



<br /><hr /><br />



# 4. 함수 정의

함수를 생성하기 위한 작업을 `함수 정의` 라고 합니다.

위에서 살펴보았던 `함수 리터럴` 도 `함수 정의` 중 하나 입니다.

<br />

아래는 `함수 정의` 방법 4가지 입니다.

* 함수 선언문
* 함수 표현식
* Function 생성자 함수
* 화살표 함수



<br /><hr /><br />



## 4-1. 함수 선언문

자바스크립트의 `중괄호 {}` 는 `중의적 표현` 입니다.

`중괄호 {}` 는 두가지 경우에서 사용합니다.

* 객체 리터럴: 값으로 평가되는 `표현식` 입니다.
* 블록문: `표현식이 아닌 문` 입니다.

<br />

`블록문` 은 값으로 평가되지 않기 때문에, `블록문` 을 변수에 할당하면, 변수는 `undefined` 가 됩니다.

<br />

`함수 선언문` 은 `기명 함수 리터럴` 과 동일하며, 여기에 사용한 `중괄호 {}` 는 `블록문` 으로써 사용됩니다.

```javascript
function add(a, b) {
  return a + b;
}
```

<br />

`함수 선언문` 은 `블록문` 이기 때문에, 실행 결과를 변수에 대입하면 `undefined` 가 될 것으로 기대하지만, `함수 선언문` 을 변수에 할당하게 되면, 변수에는 `함수 참조값` 이 저장되게 됩니다.

이는 `중괄호 {}` 가 `중립적 표현` 이며, `함수 선언문` 을 `블록문` 이 아닌 `객체 리터럴` 로 해석하기 때문입니다.

<br />

즉 `함수 선언문 (=== 기명 함수 리터럴)` 을 `피연산자` 로 사용하게 되면, `객체 리터럴 표현식` 이 됩니다.

```javascript
function add(a, b) {
  return a + b;
}

console.log(add(1, 2)); // 3

const subRef = function sub(a, b) {
  return a - b;
};

console.log(subRef(10, 3)); // 7
```



<br /><hr /><br />



## 4-2. 함수 표현식

함수는 `객체` 입니다.

그래서 `값` 으로 사용할 수 있으며, `함수 리터럴` 로 생성하여 변수에 할당할 수 있습니다.

이렇게 `함수 리터럴` 로 생성한 함수를 `변수에 할당` 하는 `함수 정의` 방식을 `함수 표현식` 이라고 합니다.

```javascript
// 무명 함수 표현식
const add = function(a, b) {
  return a + b;
};

console.log(add(1, 2)); // 3

// 기명 함수 표현식
const sub = function _sub(a, b) {
  return a - b;
};

console.log(sub(10, 7)); // 3
```



<br /><hr /><br />



## 4-3. 함수 생성 시점과 함수 호이스팅

자바스크립트의 `모든 선언문` 은 `런타임 이전` 에 자바스크립트 엔진에 의해 `먼저 실행` 됩니다.

`함수 선언문` 도 `선언문` 이므로, `런타임 이전` 에 `먼저 실행` 됩니다.

그래서 아래 코드처럼 `함수 선언문` 이전에 호출하여도 정상적으로 호출할 수 있습니다.

```javascript
console.log(add(1, 2)); // 3

function add(a, b) {
  return a + b;
}
```

<br />

만약 `함수 표현식` 에 적용할 경우, `함수 표현식` 이전에 함수를 호출하면, `타입 에러` 가 발생하게 됩니다.

```javascript
console.log(add(1, 2)); // Error 발생

const add = function(a, b) {
  return a + b;
};
```

<br />

이는 `함수 선언문 초기화` 와 `변수 선언 초기화` 의 동작이 달라서 발생하는 현상 입니다.

`함수 선언문 초기화` 는 `함수 객체` 로 초기화가 됩니다.

반면 `변수 선언 초기화` 는 `undefined` 로 초기화가 됩니다.

이러한 초기화 동작 차이에 의해, `함수 표현식` 은 반드시 `함수 표현식이 호출된 이후` 에 사용할 수 있습니다.

<br />

위에서 언급했던 `함수 선언문` 이전에 해당 함수를 호출할 수 있는 현상을 `함수 호이스팅` 이라고 합니다.

그리고 `함수 표현식` 은 `변수 초기화` 방식으로 동작하게 되기 때문에 `undefined` 로 초기화가 되므로, `함수 표현식` 이후에만 호출할 수 있게 됩니다.



<br /><hr /><br />



## 4-4. Function 생성자 함수

함수를 정의하기 윈한 방법중, `빌트인 함수` 인 `Function` 으로도 함수를 정의할 수 있습니다.

```javascript
const add = new Function('a', 'b', 'return a + b');
console.log(add(10, 20)); // 30
```

<br />

`함수 선언문` 이나 `함수 표현식` 과는 큰 차이점을 가지는데, `클로저 (Closure)` 를 생성하지 않는 것 입니다.

때문에 일반적으로 `Function 생성자 함수` 는 권장하지 않는 방식의 `함수 정의` 입니다.



<br /><hr /><br />



## 4-5. 화살표 함수

`화살표 함수` 도 `함수 정의` 방법중 하나 입니다.

하지만 지금까지 살펴본 `function` 키워드로 정의한 함수와는 내부 동작에서 차이점이 있습니다.

아래 요소들은 `화살표 함수` 특징 입니다.

* `Function 생성자 함수` 로는 사용 불가능 합니다.
* `this` 바인딩이 다릅니다.
* `prototype` 프로퍼티가 없습니다.
* `arguments` 객체를 생성하지 않습니다.



<br /><hr /><br />



## 5. 함수 호출

